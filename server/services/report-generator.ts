
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit';
import { SymptomPrediction } from '@shared/schema';

export interface ReportOptions {
  includeImages?: boolean;
  includeDomainInsights?: boolean;
  includeRecommendations?: boolean;
  patientId?: string;
  practitionerName?: string;
}

export async function generateDiagnosticReport(
  prediction: SymptomPrediction,
  options: ReportOptions = {}
): Promise<string> {
  // Create a PDF document
  const doc = new PDFDocument({ margin: 50 });
  
  // Create output file
  const reportId = `report-${Date.now()}`;
  const outputPath = path.join(__dirname, '../temp', `${reportId}.pdf`);
  const outputDir = path.dirname(outputPath);
  
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Pipe the PDF to the output file
  const stream = fs.createWriteStream(outputPath);
  doc.pipe(stream);
  
  // Add logo and header
  doc.fontSize(25).text('DentaMind AI', { align: 'center' });
  doc.fontSize(15).text('Dental Diagnostic Report', { align: 'center' });
  doc.moveDown();
  
  // Add date and patient info
  doc.fontSize(10);
  doc.text(`Date: ${new Date().toLocaleDateString()}`, { align: 'right' });
  if (options.patientId) {
    doc.text(`Patient ID: ${options.patientId}`, { align: 'right' });
  }
  if (options.practitionerName) {
    doc.text(`Practitioner: ${options.practitionerName}`, { align: 'right' });
  }
  doc.moveDown(2);
  
  // Add summary section
  doc.fontSize(14).text('Diagnostic Summary', { underline: true });
  doc.fontSize(10);
  
  // Add possible conditions
  doc.moveDown();
  if (prediction.possibleConditions && prediction.possibleConditions.length > 0) {
    doc.fontSize(12).text('Potential Diagnoses:');
    doc.moveDown(0.5);
    
    prediction.possibleConditions.forEach((condition, index) => {
      doc.fontSize(10);
      doc.text(`${index + 1}. ${condition.condition} (${Math.round(condition.confidence * 100)}% confidence)`);
      doc.text(`   Description: ${condition.description}`);
      doc.text(`   Urgency: ${condition.urgencyLevel.toUpperCase()}`);
      
      if (condition.specialistReferral) {
        doc.text(`   Specialist Referral: ${condition.specialistReferral.type} - ${condition.specialistReferral.reason}`);
      }
      
      if (options.includeRecommendations && condition.recommendations) {
        doc.moveDown(0.5);
        doc.text('   Recommendations:');
        condition.recommendations.forEach(rec => {
          doc.text(`     • ${rec}`);
        });
      }
      
      doc.moveDown();
    });
  } else {
    doc.text('No specific conditions identified.');
  }
  
  // Add AI domain insights
  if (options.includeDomainInsights && prediction.aiDomains) {
    doc.addPage();
    doc.fontSize(14).text('Specialized AI Domain Analysis', { underline: true });
    doc.moveDown();
    
    Object.entries(prediction.aiDomains).forEach(([domain, data]) => {
      doc.fontSize(12).text(domain.charAt(0).toUpperCase() + domain.slice(1));
      doc.moveDown(0.5);
      
      if (data.findings && data.findings.length) {
        doc.fontSize(10).text('Findings:');
        data.findings.forEach(finding => {
          doc.text(`  • ${finding}`);
        });
        doc.moveDown(0.5);
      }
      
      if (data.recommendations && data.recommendations.length) {
        doc.fontSize(10).text('Recommendations:');
        data.recommendations.forEach(rec => {
          doc.text(`  • ${rec}`);
        });
      }
      
      doc.moveDown();
    });
  }
  
  // Add general advice
  if (prediction.generalAdvice) {
    doc.moveDown();
    doc.fontSize(12).text('General Advice:');
    doc.fontSize(10).text(prediction.generalAdvice);
  }
  
  // Add footer
  doc.fontSize(8);
  const bottomPosition = doc.page.height - 50;
  doc.text('Generated by DentaMind AI - For clinical reference only', {
    align: 'center',
    baseline: 'bottom'
  });
  
  // Finalize the PDF
  doc.end();
  
  // Return the path when the stream is closed
  return new Promise((resolve, reject) => {
    stream.on('finish', () => resolve(outputPath));
    stream.on('error', reject);
  });
}
