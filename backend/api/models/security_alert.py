"""
Security Alert Models

This module provides models for tracking security alerts generated by the
anomaly detection system, including their resolution status.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum
from sqlalchemy import (
    Column, String, Integer, Boolean, DateTime, 
    JSON, ForeignKey, Index, Text, func, Enum as SQLEnum
)
from pydantic import BaseModel, Field

from ..database import Base, AsyncSession, get_async_session

class AlertCategory(str, Enum):
    """Categories for security alerts"""
    ACCESS = "access"    # Unusual data access patterns
    AUTH = "auth"        # Authentication related issues
    API = "api"          # API usage patterns
    LOCATION = "location"  # Geographic/IP related
    BEHAVIOR = "behavior"  # User behavior anomalies
    SYSTEM = "system"    # System level issues


class AlertSeverity(str, Enum):
    """Severity levels for security alerts"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertStatus(str, Enum):
    """Resolution status for security alerts"""
    OPEN = "open"                # New alert, not yet reviewed
    ACKNOWLEDGED = "acknowledged"  # Seen by admin, under investigation
    FALSE_POSITIVE = "false_positive"  # Confirmed to be a false alarm
    RESOLVED = "resolved"        # Issue resolved, alert closed
    ESCALATED = "escalated"      # Escalated to higher authority


class SecurityAlert(Base):
    """
    Database model for security alerts generated by anomaly detection.
    
    Tracks the full lifecycle of security incidents from detection to resolution.
    """
    __tablename__ = "security_alerts"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    alert_id = Column(String(36), nullable=False, unique=True, index=True)  # UUID
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    
    # Alert details
    alert_type = Column(String(50), nullable=False, index=True)  # e.g. multiple_failed_logins
    category = Column(SQLEnum(AlertCategory), nullable=False, index=True)
    severity = Column(SQLEnum(AlertSeverity), nullable=False, index=True)
    description = Column(Text, nullable=False)
    
    # Affected entities
    user_id = Column(String(50), nullable=True, index=True)
    ip_address = Column(String(50), nullable=True, index=True)
    patient_id = Column(String(50), nullable=True, index=True)
    resource_path = Column(String(255), nullable=True)  # API path or resource
    
    # Alert metadata
    source = Column(String(50), nullable=False, default="anomaly_detection")  # Source system
    count = Column(Integer, nullable=False, default=1)  # Occurrence count
    details = Column(JSON, nullable=True)  # Additional alert-specific details
    
    # Resolution tracking
    status = Column(SQLEnum(AlertStatus), nullable=False, default=AlertStatus.OPEN, index=True)
    assigned_to = Column(String(50), nullable=True, index=True)  # User assigned for investigation
    resolved_by = Column(String(50), nullable=True)  # User who resolved the alert
    resolution_time = Column(DateTime, nullable=True)  # When the alert was resolved
    resolution_notes = Column(Text, nullable=True)  # Notes about the resolution
    
    # Timestamps for status changes
    acknowledged_at = Column(DateTime, nullable=True)
    acknowledged_by = Column(String(50), nullable=True)
    escalated_at = Column(DateTime, nullable=True)
    escalated_by = Column(String(50), nullable=True)
    
    # Index for common queries
    __table_args__ = (
        Index('ix_security_alerts_status_severity', 'status', 'severity'),
        Index('ix_security_alerts_timestamp_status', 'timestamp', 'status'),
        Index('ix_security_alerts_user_status', 'user_id', 'status'),
    )
    
    async def save(self):
        """Save the security alert to the database"""
        async with AsyncSession() as session:
            session.add(self)
            await session.commit()
            await session.refresh(self)
            return self

# Pydantic models for API validation and responses

class SecurityAlertBase(BaseModel):
    """Base security alert attributes"""
    alert_type: str
    category: AlertCategory
    severity: AlertSeverity
    description: str
    user_id: Optional[str] = None
    ip_address: Optional[str] = None
    patient_id: Optional[str] = None
    resource_path: Optional[str] = None
    count: int = 1
    details: Optional[Dict[str, Any]] = None


class SecurityAlertCreate(SecurityAlertBase):
    """Model for creating a new security alert"""
    source: str = "anomaly_detection"
    alert_id: Optional[str] = None  # Can be provided or generated


class SecurityAlertUpdate(BaseModel):
    """Model for updating security alert status"""
    status: AlertStatus
    assigned_to: Optional[str] = None
    resolution_notes: Optional[str] = None


class SecurityAlertResponse(SecurityAlertBase):
    """Model for security alert responses"""
    id: int
    alert_id: str
    timestamp: datetime
    status: AlertStatus
    assigned_to: Optional[str] = None
    resolved_by: Optional[str] = None
    resolution_time: Optional[datetime] = None
    resolution_notes: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    escalated_at: Optional[datetime] = None
    escalated_by: Optional[str] = None
    
    class Config:
        orm_mode = True


class SecurityAlertFilter(BaseModel):
    """Model for filtering security alerts"""
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    alert_type: Optional[str] = None
    category: Optional[AlertCategory] = None
    severity: Optional[List[AlertSeverity]] = None
    status: Optional[List[AlertStatus]] = None
    user_id: Optional[str] = None
    ip_address: Optional[str] = None
    patient_id: Optional[str] = None


class ResolutionStats(BaseModel):
    """Statistics about alert resolutions"""
    total_alerts: int
    open_alerts: int
    acknowledged_alerts: int
    resolved_alerts: int
    false_positives: int
    escalated_alerts: int
    avg_resolution_time_hours: Optional[float] = None
    alerts_by_severity: Dict[str, int]
    alerts_by_category: Dict[str, int]


async def create_security_alert_from_anomaly(anomaly: Dict[str, Any]) -> SecurityAlert:
    """
    Create a SecurityAlert from an anomaly detection result
    
    Args:
        anomaly: Dictionary containing anomaly details
        
    Returns:
        Created SecurityAlert instance
    """
    from uuid import uuid4
    
    # Map anomaly type to category
    type_to_category = {
        # Authentication anomalies
        "multiple_failed_logins": AlertCategory.AUTH,
        "user_multiple_failed_logins": AlertCategory.AUTH,
        
        # Access anomalies
        "excessive_patient_access": AlertCategory.ACCESS,
        "many_patients_accessed": AlertCategory.ACCESS,
        "unusual_hours_access": AlertCategory.ACCESS,
        
        # Behavioral anomalies
        "behavioral_anomaly": AlertCategory.BEHAVIOR,
        
        # Location anomalies
        "new_ip_address": AlertCategory.LOCATION,
        
        # API anomalies
        "api_abuse": AlertCategory.API,
        "api_scraping": AlertCategory.API
    }
    
    # Map severity
    severity_mapping = {
        "high": AlertSeverity.HIGH,
        "medium": AlertSeverity.MEDIUM,
        "low": AlertSeverity.LOW
    }
    
    # Extract data from anomaly
    alert_type = anomaly.get("type", "unknown")
    category = type_to_category.get(alert_type, AlertCategory.SYSTEM)
    severity = severity_mapping.get(anomaly.get("severity", "medium"), AlertSeverity.MEDIUM)
    
    # Create alert with critical severity if it meets certain conditions
    if severity == AlertSeverity.HIGH and (
        "patient_id" in anomaly or 
        alert_type in ["multiple_failed_logins", "api_scraping"] or
        (anomaly.get("count", 0) > 20)
    ):
        severity = AlertSeverity.CRITICAL
    
    # Create the alert
    alert = SecurityAlert(
        alert_id=str(uuid4()),
        alert_type=alert_type,
        category=category,
        severity=severity,
        description=anomaly.get("description", "No description provided"),
        user_id=anomaly.get("user_id"),
        ip_address=anomaly.get("ip_address"),
        patient_id=anomaly.get("patient_id"),
        resource_path=anomaly.get("path"),
        count=anomaly.get("count", 1),
        details=anomaly,
        status=AlertStatus.OPEN
    )
    
    # Save to database
    await alert.save()
    return alert


async def update_alert_status(
    alert_id: str, 
    status: AlertStatus, 
    user_id: str, 
    notes: Optional[str] = None
) -> Optional[SecurityAlert]:
    """
    Update the status of a security alert
    
    Args:
        alert_id: The UUID of the alert to update
        status: The new status
        user_id: The ID of the user making the update
        notes: Optional notes about the status change
        
    Returns:
        Updated SecurityAlert or None if not found
    """
    async with AsyncSession() as session:
        # Find the alert
        query = "SELECT * FROM security_alerts WHERE alert_id = :alert_id"
        result = await session.execute(query, {"alert_id": alert_id})
        alert = result.scalar_one_or_none()
        
        if not alert:
            return None
            
        # Update the status and related fields
        alert.status = status
        
        # Set appropriate timestamps based on the new status
        now = datetime.utcnow()
        
        if status == AlertStatus.ACKNOWLEDGED and not alert.acknowledged_at:
            alert.acknowledged_at = now
            alert.acknowledged_by = user_id
            
        elif status == AlertStatus.ESCALATED and not alert.escalated_at:
            alert.escalated_at = now
            alert.escalated_by = user_id
            
        elif status in [AlertStatus.RESOLVED, AlertStatus.FALSE_POSITIVE]:
            alert.resolution_time = now
            alert.resolved_by = user_id
            
        # Update notes if provided
        if notes:
            alert.resolution_notes = notes
            
        # Save changes
        await session.commit()
        await session.refresh(alert)
        
        return alert


async def get_security_alerts(
    filter_params: SecurityAlertFilter,
    limit: int = 100,
    offset: int = 0
) -> List[SecurityAlert]:
    """Get security alerts with filtering"""
    async with AsyncSession() as session:
        # Build the query
        query = "SELECT * FROM security_alerts WHERE 1=1"
        params = {}
        
        # Add filter conditions
        if filter_params.start_time:
            query += " AND timestamp >= :start_time"
            params["start_time"] = filter_params.start_time
            
        if filter_params.end_time:
            query += " AND timestamp <= :end_time"
            params["end_time"] = filter_params.end_time
            
        if filter_params.alert_type:
            query += " AND alert_type = :alert_type"
            params["alert_type"] = filter_params.alert_type
            
        if filter_params.category:
            query += " AND category = :category"
            params["category"] = filter_params.category
            
        if filter_params.severity:
            placeholders = [f":severity_{i}" for i in range(len(filter_params.severity))]
            query += f" AND severity IN ({','.join(placeholders)})"
            for i, sev in enumerate(filter_params.severity):
                params[f"severity_{i}"] = sev
            
        if filter_params.status:
            placeholders = [f":status_{i}" for i in range(len(filter_params.status))]
            query += f" AND status IN ({','.join(placeholders)})"
            for i, stat in enumerate(filter_params.status):
                params[f"status_{i}"] = stat
            
        if filter_params.user_id:
            query += " AND user_id = :user_id"
            params["user_id"] = filter_params.user_id
            
        if filter_params.ip_address:
            query += " AND ip_address = :ip_address"
            params["ip_address"] = filter_params.ip_address
            
        if filter_params.patient_id:
            query += " AND patient_id = :patient_id"
            params["patient_id"] = filter_params.patient_id
            
        # Add ordering and pagination
        query += " ORDER BY timestamp DESC LIMIT :limit OFFSET :offset"
        params["limit"] = limit
        params["offset"] = offset
        
        # Execute the query
        result = await session.execute(query, params)
        return result.scalars().all()


async def count_security_alerts(filter_params: SecurityAlertFilter) -> int:
    """Count security alerts with filtering"""
    async with AsyncSession() as session:
        # Build the query
        query = "SELECT COUNT(*) FROM security_alerts WHERE 1=1"
        params = {}
        
        # Add filter conditions
        if filter_params.start_time:
            query += " AND timestamp >= :start_time"
            params["start_time"] = filter_params.start_time
            
        if filter_params.end_time:
            query += " AND timestamp <= :end_time"
            params["end_time"] = filter_params.end_time
            
        if filter_params.alert_type:
            query += " AND alert_type = :alert_type"
            params["alert_type"] = filter_params.alert_type
            
        if filter_params.category:
            query += " AND category = :category"
            params["category"] = filter_params.category
            
        if filter_params.severity:
            placeholders = [f":severity_{i}" for i in range(len(filter_params.severity))]
            query += f" AND severity IN ({','.join(placeholders)})"
            for i, sev in enumerate(filter_params.severity):
                params[f"severity_{i}"] = sev
            
        if filter_params.status:
            placeholders = [f":status_{i}" for i in range(len(filter_params.status))]
            query += f" AND status IN ({','.join(placeholders)})"
            for i, stat in enumerate(filter_params.status):
                params[f"status_{i}"] = stat
            
        if filter_params.user_id:
            query += " AND user_id = :user_id"
            params["user_id"] = filter_params.user_id
            
        if filter_params.ip_address:
            query += " AND ip_address = :ip_address"
            params["ip_address"] = filter_params.ip_address
            
        if filter_params.patient_id:
            query += " AND patient_id = :patient_id"
            params["patient_id"] = filter_params.patient_id
            
        # Execute the query
        result = await session.execute(query, params)
        return result.scalar_one()


async def get_resolution_stats(
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None
) -> ResolutionStats:
    """Get statistics about alert resolutions"""
    async with AsyncSession() as session:
        # Build the query for total counts by status
        query = """
        SELECT 
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE status = 'open') as open_count,
            COUNT(*) FILTER (WHERE status = 'acknowledged') as ack_count,
            COUNT(*) FILTER (WHERE status = 'resolved') as resolved_count,
            COUNT(*) FILTER (WHERE status = 'false_positive') as false_positive_count,
            COUNT(*) FILTER (WHERE status = 'escalated') as escalated_count,
            AVG(EXTRACT(EPOCH FROM (resolution_time - timestamp))/3600) 
                FILTER (WHERE resolution_time IS NOT NULL) as avg_resolution_hours
        FROM security_alerts
        WHERE 1=1
        """
        
        params = {}
        
        if start_time:
            query += " AND timestamp >= :start_time"
            params["start_time"] = start_time
            
        if end_time:
            query += " AND timestamp <= :end_time"
            params["end_time"] = end_time
            
        result = await session.execute(query, params)
        row = result.fetchone()
        
        # Get counts by severity
        severity_query = """
        SELECT severity, COUNT(*) as count
        FROM security_alerts
        WHERE 1=1
        """
        
        if start_time:
            severity_query += " AND timestamp >= :start_time"
        if end_time:
            severity_query += " AND timestamp <= :end_time"
            
        severity_query += " GROUP BY severity"
        
        severity_result = await session.execute(severity_query, params)
        by_severity = {row.severity: row.count for row in severity_result}
        
        # Get counts by category
        category_query = """
        SELECT category, COUNT(*) as count
        FROM security_alerts
        WHERE 1=1
        """
        
        if start_time:
            category_query += " AND timestamp >= :start_time"
        if end_time:
            category_query += " AND timestamp <= :end_time"
            
        category_query += " GROUP BY category"
        
        category_result = await session.execute(category_query, params)
        by_category = {row.category: row.count for row in category_result}
        
        # Assemble the stats
        stats = ResolutionStats(
            total_alerts=row.total,
            open_alerts=row.open_count,
            acknowledged_alerts=row.ack_count,
            resolved_alerts=row.resolved_count,
            false_positives=row.false_positive_count,
            escalated_alerts=row.escalated_count,
            avg_resolution_time_hours=row.avg_resolution_hours,
            alerts_by_severity=by_severity,
            alerts_by_category=by_category
        )
        
        return stats 