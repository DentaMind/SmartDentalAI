import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { EvidenceCitation } from './clinicalEvidenceService';

// Extend the jsPDF type to include autotable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface PatientInfo {
  id: string;
  first_name: string;
  last_name: string;
  date_of_birth?: string;
  patient_id?: string;
}

interface DiagnosisInfo {
  id: string;
  diagnosis_name?: string;
  finding_type?: string;
  type?: string;
}

interface TreatmentSuggestion {
  id: string;
  procedure_name: string;
  procedure_code?: string;
  tooth_number?: string;
  finding_type?: string;
  priority?: string;
  confidence?: number;
  notes?: string;
  specialty_area?: string;
}

interface TreatmentPlanExportOptions {
  includeConfidenceScores?: boolean;
  includeEvidenceDetails?: boolean;
  includeClinicalReferences?: boolean;
  title?: string;
  subtitle?: string;
  logoUrl?: string;
  footerText?: string;
}

/**
 * Service for generating PDF exports of treatment plans with clinical evidence
 */
class PdfExportService {
  /**
   * Generate a PDF report of an evidence-based treatment plan
   * 
   * @param patient - Patient information
   * @param diagnosis - Diagnosis information
   * @param treatments - List of treatment suggestions
   * @param evidenceMap - Map of treatment IDs to evidence citations
   * @param options - Export options
   * @returns Blob containing the PDF document
   */
  generateTreatmentPlanPDF = async (
    patient: PatientInfo,
    diagnosis: DiagnosisInfo,
    treatments: TreatmentSuggestion[],
    evidenceMap: Record<string, EvidenceCitation[]>,
    options: TreatmentPlanExportOptions = {}
  ): Promise<Blob> => {
    // Create a new PDF document
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Default options
    const defaultOptions = {
      includeConfidenceScores: true,
      includeEvidenceDetails: true,
      includeClinicalReferences: true,
      title: 'Evidence-Based Treatment Plan',
      subtitle: 'DentaMind AI Clinical Recommendations',
      footerText: 'This report was generated by DentaMind AI and should be reviewed by a dental professional.'
    };

    const exportOptions = { ...defaultOptions, ...options };
    
    // Add title and subtitle
    doc.setFontSize(20);
    doc.setTextColor(0, 91, 187); // Medical blue
    doc.text(exportOptions.title, 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setTextColor(100, 100, 100); // Gray
    doc.text(exportOptions.subtitle, 105, 27, { align: 'center' });
    
    // Add current date
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 105, 33, { align: 'center' });
    
    // Add horizontal line
    doc.setDrawColor(220, 220, 220);
    doc.line(20, 38, 190, 38);
    
    // Add patient information
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text('Patient Information', 20, 48);
    
    doc.setFontSize(11);
    doc.text(`Name: ${patient.first_name} ${patient.last_name}`, 20, 55);
    if (patient.date_of_birth) {
      doc.text(`DOB: ${new Date(patient.date_of_birth).toLocaleDateString()}`, 20, 61);
    }
    if (patient.patient_id) {
      doc.text(`Patient ID: ${patient.patient_id}`, 20, 67);
    }
    
    // Add diagnosis information
    doc.setFontSize(12);
    doc.text('Diagnosis Information', 110, 48);
    
    doc.setFontSize(11);
    doc.text(`Diagnosis: ${diagnosis.diagnosis_name || diagnosis.type || 'Not specified'}`, 110, 55);
    if (diagnosis.finding_type) {
      doc.text(`Finding: ${diagnosis.finding_type}`, 110, 61);
    }
    
    // Add treatment recommendations table
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text('Recommended Treatments', 20, 80);
    
    // Prepare treatment table
    const treatmentTableHeaders = [
      'Treatment',
      'Tooth',
      'Priority',
      ...(exportOptions.includeConfidenceScores ? ['Confidence'] : []),
      'Evidence'
    ];
    
    const treatmentTableRows = treatments.map(treatment => {
      const evidenceCount = evidenceMap[treatment.id]?.length || 0;
      const evidenceGrades = evidenceMap[treatment.id]?.map(e => e.evidence_grade) || [];
      
      // Calculate highest grade (A is highest)
      const highestGrade = evidenceGrades.sort()[0] || 'N/A';
      
      // Format evidence info
      let evidenceInfo = `${evidenceCount} source${evidenceCount !== 1 ? 's' : ''}`;
      if (evidenceCount > 0) {
        evidenceInfo += ` (Grade ${highestGrade})`;
      }
      
      return [
        `${treatment.procedure_name}\n${treatment.procedure_code || ''}`,
        treatment.tooth_number || 'N/A',
        treatment.priority || 'Standard',
        ...(exportOptions.includeConfidenceScores ? [
          treatment.confidence ? `${Math.round(treatment.confidence * 100)}%` : 'N/A'
        ] : []),
        evidenceInfo
      ];
    });
    
    // Add treatments table
    doc.autoTable({
      head: [treatmentTableHeaders],
      body: treatmentTableRows,
      startY: 85,
      headStyles: {
        fillColor: [0, 91, 187],
        textColor: [255, 255, 255],
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 3
      },
      columnStyles: {
        0: { cellWidth: 60 },
        1: { cellWidth: 20, halign: 'center' },
        2: { cellWidth: 25, halign: 'center' },
        ...(exportOptions.includeConfidenceScores ? { 3: { cellWidth: 25, halign: 'center' } } : {}),
        [exportOptions.includeConfidenceScores ? 4 : 3]: { cellWidth: 40, halign: 'center' }
      }
    });
    
    // Get the Y position after the treatments table
    const finalY = (doc as any).lastAutoTable.finalY || 150;
    
    // Add clinical evidence details if enabled
    if (exportOptions.includeEvidenceDetails) {
      doc.addPage();
      
      doc.setFontSize(14);
      doc.setTextColor(0, 91, 187);
      doc.text('Supporting Clinical Evidence', 105, 20, { align: 'center' });
      
      doc.setFontSize(10);
      doc.setTextColor(100, 100, 100);
      doc.text('The following clinical evidence supports the recommended treatments', 105, 27, { align: 'center' });
      
      doc.setDrawColor(220, 220, 220);
      doc.line(20, 32, 190, 32);
      
      // Group evidence by treatment
      let startY = 40;
      let currentPage = doc.getNumberOfPages();
      
      treatments.forEach(treatment => {
        const evidenceList = evidenceMap[treatment.id] || [];
        
        if (evidenceList.length === 0) {
          return; // Skip treatments without evidence
        }
        
        // Check if we need to add a new page
        if (startY > 250) {
          doc.addPage();
          startY = 20;
          currentPage = doc.getNumberOfPages();
        }
        
        // Add treatment header
        doc.setPage(currentPage);
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        doc.text(`${treatment.procedure_name} (${treatment.procedure_code || 'No code'})`, 20, startY);
        
        startY += 7;
        
        // Add evidence entries
        evidenceList.forEach((evidence, index) => {
          // Check if we need to add a new page
          if (startY > 250) {
            doc.addPage();
            startY = 20;
            currentPage = doc.getNumberOfPages();
          }
          
          doc.setPage(currentPage);
          
          // Grade badge
          const gradeColors: Record<string, [number, number, number]> = {
            'A': [0, 200, 83], // Green
            'B': [100, 221, 23], // Light green
            'C': [255, 214, 0], // Yellow
            'D': [255, 145, 0], // Orange
          };
          
          const gradeColor = gradeColors[evidence.evidence_grade] || [117, 117, 117];
          
          // Draw colored grade indicator
          doc.setFillColor(...gradeColor);
          doc.circle(23, startY + 2, 3, 'F');
          
          // Evidence title and type
          doc.setFontSize(11);
          doc.setTextColor(0, 0, 0);
          doc.text(`${evidence.title}`, 28, startY);
          
          // Evidence type and publication
          startY += 6;
          doc.setFontSize(9);
          doc.setTextColor(100, 100, 100);
          
          let evidenceType = '';
          switch (evidence.evidence_type) {
            case 'guideline': evidenceType = 'Clinical Guideline'; break;
            case 'systematic_review': evidenceType = 'Systematic Review'; break;
            case 'clinical_trial': evidenceType = 'Clinical Trial'; break;
            case 'cohort_study': evidenceType = 'Cohort Study'; break;
            case 'case_control': evidenceType = 'Case-Control Study'; break;
            case 'case_series': evidenceType = 'Case Series'; break;
            case 'expert_opinion': evidenceType = 'Expert Opinion'; break;
            default: evidenceType = evidence.evidence_type;
          }
          
          const publicationInfo = [
            evidenceType,
            evidence.publication,
            evidence.publication_date ? new Date(evidence.publication_date.toString()).getFullYear() : null
          ].filter(Boolean).join(' â€¢ ');
          
          doc.text(publicationInfo, 28, startY);
          
          // Evidence quote or summary
          if (evidence.quote || evidence.summary) {
            startY += 6;
            
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            
            // Create a slightly indented, boxed area for the quote
            const quoteText = evidence.quote || evidence.summary || '';
            
            // Split text to fit width
            const textLines = doc.splitTextToSize(quoteText, 150);
            
            // Draw light gray background for quote
            doc.setFillColor(245, 245, 245);
            doc.rect(28, startY - 3, 155, textLines.length * 5 + 4, 'F');
            
            // Add left border to quote
            doc.setDrawColor(...gradeColor);
            doc.setLineWidth(1);
            doc.line(28, startY - 3, 28, startY + textLines.length * 5 + 1);
            
            // Reset line width
            doc.setLineWidth(0.2);
            
            // Add the text
            doc.text(textLines, 31, startY);
            
            // Update Y position based on number of lines
            startY += textLines.length * 5 + 5;
          }
          
          // Source link
          if (exportOptions.includeClinicalReferences && (evidence.doi || evidence.url)) {
            startY += 4;
            doc.setFontSize(8);
            doc.setTextColor(0, 91, 187);
            
            const sourceText = evidence.doi 
              ? `DOI: ${evidence.doi}`
              : evidence.url || '';
            
            doc.text(sourceText, 28, startY);
            startY += 5;
          }
          
          // Add spacing between evidence items
          startY += 6;
        });
        
        // Add spacing between treatments
        startY += 8;
      });
    }
    
    // Add footer to all pages
    const pageCount = doc.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150, 150, 150);
      
      // Add footer text
      doc.text(exportOptions.footerText, 105, 285, { align: 'center' });
      
      // Add page number
      doc.text(`Page ${i} of ${pageCount}`, 185, 285, { align: 'right' });
    }
    
    // Return the PDF as a blob
    return doc.output('blob');
  };
  
  /**
   * Generate and download a PDF report of an evidence-based treatment plan
   * 
   * @param patient - Patient information
   * @param diagnosis - Diagnosis information
   * @param treatments - List of treatment suggestions
   * @param evidenceMap - Map of treatment IDs to evidence citations
   * @param options - Export options
   * @param fileName - Filename for the downloaded PDF (default: generated based on patient name)
   */
  downloadTreatmentPlanPDF = async (
    patient: PatientInfo,
    diagnosis: DiagnosisInfo,
    treatments: TreatmentSuggestion[],
    evidenceMap: Record<string, EvidenceCitation[]>,
    options: TreatmentPlanExportOptions = {},
    fileName?: string
  ): Promise<void> => {
    const pdfBlob = await this.generateTreatmentPlanPDF(
      patient,
      diagnosis,
      treatments,
      evidenceMap,
      options
    );
    
    // Create a default filename based on patient info if not provided
    const defaultFileName = `treatment-plan_${patient.last_name}_${patient.first_name}_${new Date().toISOString().split('T')[0]}.pdf`;
    const downloadFileName = fileName || defaultFileName;
    
    // Create a download link and trigger download
    const url = URL.createObjectURL(pdfBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = downloadFileName;
    link.click();
    
    // Clean up
    URL.revokeObjectURL(url);
  };
}

export default new PdfExportService(); 